// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title YieldToken
 * @notice ERC20 token representing the yield portion of a yield-bearing position
 * @dev YT tokens accrue yield from the underlying until maturity
 * 
 * Yield Token Mechanics:
 * - YT holder receives all yield generated by underlying until maturity
 * - After maturity, YT has no value (all yield distributed)
 * - YT price = PV of expected future yield
 * 
 * Example:
 * - Hold 100 YT-aUSDT, underlying yields 5% APY
 * - Receive ~5 USDT over the year (distributed continuously)
 * - At maturity: YT = 0 value
 */
contract YieldToken is ERC20, ERC20Permit, Ownable {
    
    // ============ State Variables ============
    
    /// @notice The underlying yield-bearing asset
    address public immutable underlying;
    
    /// @notice The yield tokenizer contract
    address public tokenizer;
    
    /// @notice Maturity timestamp
    uint256 public immutable maturity;
    
    /// @notice Whether the token has matured
    bool public matured;
    
    /// @notice Accumulated yield per token (scaled by 1e18)
    uint256 public yieldPerToken;
    
    /// @notice User's yield per token at last interaction
    mapping(address => uint256) public userYieldPerToken;
    
    /// @notice Unclaimed yield per user
    mapping(address => uint256) public unclaimedYield;
    
    // ============ Events ============
    
    event YieldAccrued(uint256 amount, uint256 newYieldPerToken);
    event YieldClaimed(address indexed user, uint256 amount);
    event Matured(uint256 timestamp);
    
    // ============ Errors ============
    
    error NotTokenizer();
    error NotMatured();
    error AlreadyMatured();
    error InvalidMaturity();
    error ZeroAddress();
    error NoYieldToClaim();
    
    // ============ Modifiers ============
    
    modifier onlyTokenizer() {
        if (msg.sender != tokenizer) revert NotTokenizer();
        _;
    }
    
    modifier notMatured() {
        if (matured) revert AlreadyMatured();
        _;
    }
    
    modifier updateYield(address _user) {
        _updateUserYield(_user);
        _;
    }
    
    // ============ Constructor ============
    
    constructor(
        string memory _name,
        string memory _symbol,
        address _underlying,
        uint256 _maturity,
        address _tokenizer
    ) ERC20(_name, _symbol) ERC20Permit(_name) Ownable(msg.sender) {
        if (_underlying == address(0)) revert ZeroAddress();
        if (_tokenizer == address(0)) revert ZeroAddress();
        if (_maturity <= block.timestamp) revert InvalidMaturity();
        
        underlying = _underlying;
        maturity = _maturity;
        tokenizer = _tokenizer;
    }
    
    // ============ Internal Functions ============
    
    /**
     * @notice Update user's accrued yield
     */
    function _updateUserYield(address _user) internal {
        if (_user == address(0)) return;
        
        uint256 balance = balanceOf(_user);
        if (balance > 0) {
            uint256 pending = (balance * (yieldPerToken - userYieldPerToken[_user])) / 1e18;
            unclaimedYield[_user] += pending;
        }
        userYieldPerToken[_user] = yieldPerToken;
    }
    
    /**
     * @notice Override transfer to update yield
     */
    function _update(address from, address to, uint256 value) internal virtual override {
        _updateUserYield(from);
        _updateUserYield(to);
        super._update(from, to, value);
    }
    
    // ============ Tokenizer Functions ============
    
    /**
     * @notice Mint YT tokens (only tokenizer)
     */
    function mint(address _to, uint256 _amount) external onlyTokenizer notMatured updateYield(_to) {
        _mint(_to, _amount);
    }
    
    /**
     * @notice Burn YT tokens (only tokenizer)
     */
    function burn(address _from, uint256 _amount) external onlyTokenizer updateYield(_from) {
        _burn(_from, _amount);
    }
    
    /**
     * @notice Distribute yield to all YT holders
     * @param _amount Amount of underlying yield to distribute
     */
    function distributeYield(uint256 _amount) external onlyTokenizer {
        uint256 supply = totalSupply();
        if (supply == 0) return;
        
        yieldPerToken += (_amount * 1e18) / supply;
        
        emit YieldAccrued(_amount, yieldPerToken);
    }
    
    // ============ User Functions ============
    
    /**
     * @notice Claim accrued yield
     */
    function claimYield() external updateYield(msg.sender) returns (uint256 amount) {
        amount = unclaimedYield[msg.sender];
        if (amount == 0) revert NoYieldToClaim();
        
        unclaimedYield[msg.sender] = 0;
        
        // Transfer yield to user from tokenizer's underlying balance
        IERC20(underlying).safeTransfer(msg.sender, amount);
        
        emit YieldClaimed(msg.sender, amount);
    }
    
    /**
     * @notice Get pending yield for user
     */
    function pendingYield(address _user) external view returns (uint256) {
        uint256 balance = balanceOf(_user);
        uint256 pending = (balance * (yieldPerToken - userYieldPerToken[_user])) / 1e18;
        return unclaimedYield[_user] + pending;
    }
    
    // ============ Maturity Functions ============
    
    /**
     * @notice Mark token as matured
     */
    function mature() external {
        if (block.timestamp < maturity) revert NotMatured();
        if (matured) revert AlreadyMatured();
        
        matured = true;
        emit Matured(block.timestamp);
    }
    
    // ============ View Functions ============
    
    /**
     * @notice Check if token has reached maturity
     */
    function isMatured() external view returns (bool) {
        return matured || block.timestamp >= maturity;
    }
    
    /**
     * @notice Time until maturity
     */
    function timeToMaturity() external view returns (uint256) {
        if (block.timestamp >= maturity) return 0;
        return maturity - block.timestamp;
    }
    
    /**
     * @notice Get theoretical YT value based on expected yield
     * @param _expectedAPY Expected annual yield in basis points (e.g., 500 = 5%)
     * @return value YT value per token in underlying terms (18 decimals)
     */
    function getTheoreticalValue(uint256 _expectedAPY) external view returns (uint256 value) {
        if (block.timestamp >= maturity) return 0;
        
        uint256 timeToMat = maturity - block.timestamp;
        
        // Value = expectedAPY * timeToMaturity / 365 days
        value = (_expectedAPY * timeToMat * 1e18) / (10000 * 365 days);
    }
    
    // ============ Admin Functions ============
    
    function setTokenizer(address _newTokenizer) external onlyOwner {
        if (_newTokenizer == address(0)) revert ZeroAddress();
        tokenizer = _newTokenizer;
    }
}
